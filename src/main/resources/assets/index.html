<html>
<head>
  <style>
    .chart div {
      font: 10px sans-serif;
      background-color: steelblue;
      text-align: right;
      padding: 3px;
      margin: 1px;
      color: white;
    }

    path {
      stroke: steelblue;
      stroke-width: 2;
      fill: none;
    }
  </style>
  <script type="text/javascript" src="/assets/jquery.min.js"></script>
  <script type="text/javascript" src="/assets/d3.v4.min.js"></script>
</head>
<body>

<div id="form"></div>

<script type="text/babel">
  // TODO: it would be nice if SetupForm was someone linked to the Crypto class...
  class CryptoForm extends React.Component {
    constructor(props) {
      super(props);
      this.state = {algorithms: {}, engines: [], results: []}
    }

    componentDidMount() {
      $.ajax({
        url: '/tests/list'
      }).done(data => {
        this.setState(data);
      }).fail(err => {
        console.error(err);
      });
    }

    render() {
      var algorithms = []
      for (var i in this.state.algorithms) {
        var alg = this.state.algorithms[i];
        algorithms.push(<option key={i} value={i}>{alg}</option>);
      }

      var engines = [];
      for (var i=0; i<this.state.engines.length; i++) {
        var engine = this.state.engines[i];
        engines.push(<option key={engine} value={engine}>{engine}</option>);
      }
      return <div>
        <form>
          <span>algorithm: <select name="algorithm">{algorithms}</select></span>&nbsp;
          <span>engine: <select name="engine">{engines}</select></span>&nbsp;
          <span>bytes: <input type="text" name="bytes" defaultValue="10"/></span>&nbsp;
          <span>iterations: <input type="text" name="iterations" defaultValue="10000"/></span>&nbsp;
          <span>threads: <input type="text" name="threads" defaultValue="100"/></span>&nbsp;
          <span><button onClick={e => this.startTest(e)}>start</button></span>
        </form>
        <div>
          {this.state.results}
        </div>
      </div>
    }

    startTest(e) {
      e.preventDefault();

      // make an Ajax request to start a test.
      $.ajax({
        url: '/tests/start?' + $('form').serialize()
      }).done(data => {
        var r = this.state.results.slice()
        r.push(<CryptoResult key={data.id} id={data.id}/>);
        this.setState({results: r})
      }).fail(err => {
        console.error(err);
        var r = this.state.results.slice()
        r.push(<b key="1">something failed: {err.status}: {err.statusText}</b>)
      });
    }
  }

  class CryptoResult extends React.Component {
    constructor(props) {
      super(props);
      this.state = {exception: null, status: "started..."}
      this.chart = null;
      this.arr = [];
    }

    componentDidMount() {
      // keep fetching data until we have everything
      this.chart = new CanvasJS.Chart("chart-" + this.props.id, {
        title: {
          text: "the chart"
        }, axisY: {maximum: 0}, data: [{type: "column", dataPoints: []}]
      });
      window.debugChart = this.chart;
      window.debugArr = this;

      this.results()
    }

    results() {
      $.ajax({
        url: '/tests/results?id=' + this.props.id + '&offset=' + this.arr.length
      }).done(data => {
        if (data.exception) {
          console.error(data.exception);
          this.setState({exception: data.exception});
        }
        for (var i = 0; i < data.startEndTimes.length; i++) {
          var v = data.startEndTimes[i].endTime - data.startEndTimes[i].startTime;
          this.arr.push(v);
          this.chart.options.data[0].dataPoints.push({x: this.arr.length, y: v});
          if (v > this.chart.options.axisY.maximum) {
            this.chart.options.axisY.maximum = v;
          }
          if (this.chart.options.data[0].dataPoints.length > 20000) {
            this.chart.options.data[0].dataPoints.shift();
          }
        }
        this.chart.render()

        // get more data
        if ((data.total == 0) || (this.arr.length < data.total)) {
          this.results();
        } else {
          this.setState({status: "done."});
          //plotPercentile(this.chart, arr)
        }
      }).fail(err => {
        console.error(err);
        this.setState({status: err.status + ": " + err.statusText})
      })
    }

    render() {
      return <div>
        <div id={"chart-" + this.props.id} style={{height: '300px', width: '100%'}}></div>
        <p>{this.state.status}</p>
        <p>{this.state.exception}</p>
      </div>;
    }
  }

  ReactDOM.render(<CryptoForm/>, document.getElementById('form'));
</script>

  <!--function plotPercentile(chart, arr) {-->
    <!--// find the min/max values. We'll then bucket the results-->
    <!--var min=0, max=0;-->
    <!--for (var i=0; i<arr.length; i++) {-->
      <!--min = (min < arr[i]) ? min : arr[i];-->
      <!--max = (max > arr[i]) ? max : arr[i];-->
    <!--}-->

    <!--var r = [];-->
    <!--var bucket_size = (max - min) / 20;-->
    <!--for (var i=min; i<max; i+=bucket_size) {-->
      <!--var y = 0;-->
      <!--for (var j=0; j<arr.length; j++) {-->
        <!--if ((arr[j] >= i) && (arr[j] < (i+bucket_size))) {-->
          <!--y++;-->
        <!--}-->
      <!--}-->
      <!--r.push({x: i, y: y/arr.length});-->
    <!--}-->

    <!--chart.options.axisY.maximum = null;-->
    <!--chart.options.axisX = {minimum: min, maximum: max};-->
    <!--chart.options.data[0].dataPoints = r;-->
    <!--chart.render()-->
  <!--}-->

</body>
</html>
